= Vert.x Shell

Vert.x Shell is a command line interface for the Vert.x runtime available from regular
terminals using different protocols.

Vert.x Shell provides a variety of commands for interacting live with Vert.x services.

Vert.x Shell can be extended with custom commands in any language supported by Vert.x

== Using Vert.x Shell

Vert.x Shell is a Vert.x Service and can be started programmatically via the `link:../../jsdoc/shell_service-ShellService.html[ShellService]`
or deployed as a service.

=== Shell service

The shell can be started as a service directly either from the command line or as a the Vert.x deployment:

.Starting a shell service available via Telnet
[source,subs="+attributes"]
----
vertx run -conf '{"telnetOptions":{"port":5000}}' maven:io.vertx:vertx-shell:3.2.0-SNAPSHOT
----

or

.Starting a shell service available via SSH
[source,subs="+attributes"]
----
# create a key pair for the SSH server
keytool -genkey -keyalg RSA -keystore ssh.jks -keysize 2048 -validity 1095 -dname CN=localhost -keypass secret -storepass secret
# create the auth config
echo user.admin=password > auth.properties
# start the shell
vertx run -conf '{"sshOptions":{"port":4000,"keyPairOptions":{"path":"ssh.jks","password":"secret"},"shiroAuthOptions":{"config":{"properties_path":"file:auth.properties"}}}}' maven:io.vertx:vertx-shell:3.2.0-SNAPSHOT
----

or

.Starting a shell service available via HTTP
[source,subs="+attributes"]
----
# create a certificate for the HTTP server
keytool -genkey -keyalg RSA -keystore keystore.jks -keysize 2048 -validity 1095 -dname CN=localhost -keypass secret -storepass secret
# create the auth config
echo user.admin=password > auth.properties
vertx run -conf '{"httpOptions":{"port":8080,"ssl":true,"keyStoreOptions":{"path":"keystore.jks","password":"secret"},"shiroAuthOptions":{"config":{"properties_path":"file:auth.properties"}}}}' maven:io.vertx:vertx-shell:3.2.0-SNAPSHOT
----

You can also deploy this service inside your own verticle:

[source,js,subs="+attributes"]
----
vertx.deployVerticle("maven:{maven-groupId}:{maven-artifactId}:{maven-version}", {
  "config" : {
    "telnetOptions" : {
      "host" : "localhost",
      "port" : 4000
    }
  }
});

----

or

[source,js,subs="+attributes"]
----
vertx.deployVerticle("maven:{maven-groupId}:{maven-artifactId}:{maven-version}", {
  "config" : {
    "sshOptions" : {
      "host" : "localhost",
      "port" : 5000,
      "keyPairOptions" : {
        "path" : "ssh.jks",
        "password" : "wibble"
      },
      "config" : {
        "properties_path" : "file:/path/to/my/auth.properties"
      }
    }
  }
});

----

or

[source,js,subs="+attributes"]
----
vertx.deployVerticle("maven:{maven-groupId}:{maven-artifactId}:{maven-version}", {
  "config" : {
    "httpOptions" : {
      "host" : "localhost",
      "port" : 8080,
      "ssl" : true,
      "keyStoreOptions" : {
        "path" : "keystore.jks",
        "password" : "wibble"
      },
      "config" : {
        "properties_path" : "file:/path/to/my/auth.properties"
      }
    }
  }
});

----

NOTE: when Vert.x Shell is already on your classpath you can use `service:io.vertx.ext.shell` instead
or `maven:io.vertx:vertx-shell:3.2.0-SNAPSHOT`

=== Programmatic service

The `link:../../jsdoc/shell_service-ShellService.html[ShellService]` takes care of starting an instance of Vert.x Shell.

Starting a shell service available via SSH:

[source,js]
----
var ShellService = require("vertx-shell-js/shell_service");
var service = ShellService.create(vertx, {
  "sSHOptions" : {
    "host" : "localhost",
    "port" : 5000,
    "keyPairOptions" : {
      "path" : "server-keystore.jks",
      "password" : "wibble"
    },
    "shiroAuthOptions" : {
      "type" : 'PROPERTIES',
      "config" : {
        "properties_path" : "file:/path/to/my/auth.properties"
      }
    }
  }
});
service.start();

----

Starting a shell service available via Telnet:

[source,js]
----
var ShellService = require("vertx-shell-js/shell_service");
var service = ShellService.create(vertx, {
  "telnetOptions" : {
    "host" : "localhost",
    "port" : 4000
  }
});
service.start();

----

The `link:../dataobjects.html#TelnetTermOptions[TelnetTermOptions]` extends the Vert.x Core `NetServerOptions` as the Telnet server
implementation is based on a `NetServer`.

CAUTION: Telnet does not provide any authentication nor encryption at all.

Starting a shell service available via HTTP:

[source,js]
----
var ShellService = require("vertx-shell-js/shell_service");
var service = ShellService.create(vertx, {
  "httpOptions" : {
    "host" : "localhost",
    "port" : 8080
  }
});
service.start();

----

== Telnet term configuration

Telnet terms are configured by `link:../dataobjects.html#ShellServiceOptions#setTelnetOptions[telnetOptions]`,
the `link:../dataobjects.html#TelnetTermOptions[TelnetTermOptions]` extends the `link:../../vertx-core/dataobjects.html#NetServerOptions[NetServerOptions]` so they
have the exact same configuration.

== SSH term configuration

SSH terms are configured by `link:../dataobjects.html#ShellServiceOptions#setSSHOptions[SSHOptions]`:

- `link:../dataobjects.html#SSHTermOptions#setPort[port]`: port
- `link:../dataobjects.html#SSHTermOptions#setHost[host]`: host

Only username/password authentication is supported at the moment, it can be configured with property file
or LDAP, see Vert.x Auth for more info:

- `link:../dataobjects.html#SSHTermOptions#setShiroAuthOptions[shiroAuthOptions]`: configures user authentication

The server key configuration reuses the key pair store configuration scheme provided by _Vert.x Core_:

- `link:../dataobjects.html#SSHTermOptions#setKeyPairOptions[keyPairOptions]`: set `.jks` key pair store
- `link:../dataobjects.html#SSHTermOptions#setPfxKeyPairOptions[pfxKeyPairOptions]`: set `.pfx` key pair store
- `link:../dataobjects.html#SSHTermOptions#setPemKeyPairOptions[pemKeyPairOptions]`: set `.pem` key pair store

== HTTP term configuration

HTTP terms are configured by `link:../dataobjects.html#ShellServiceOptions#setHttpOptions[httpOptions]`, the http options
extends the `link:../../vertx-core/dataobjects.html#HttpServerOptions[HttpServerOptions]` so they expose the exact same configuration.

In addition there are extra options for configuring an HTTP term:

- `link:../dataobjects.html#HttpTermOptions#setShiroAuthOptions[shiroAuthOptions]`: configures user authentication
- `link:../dataobjects.html#HttpTermOptions#setSockJSHandlerOptions[sockJSHandlerOptions]`: configures SockJS
- `link:../dataobjects.html#HttpTermOptions#setSockJSPath[sockJSPath]`: the SockJS path in the router

== Base commands

To find out the available commands you can use the _help_ builtin command:

. Verticle commands
.. verticle-ls: list all deployed verticles
.. verticle-undeploy: undeploy a verticle
.. verticle-deploy: deployes a verticle
.. verticle-factories: list all known verticle factories
. File system commands
.. ls
.. cd
.. pwd
. Bus commands
.. bus-tail: display all incoming messages on an event bus address
.. bus-send: send a message on the event bus
. Net commands
.. net-ls: list all available net servers, including HTTP servers
. Shared data commands
.. local-map-put
.. local-map-get
.. local-map-rm
. Metrics commands (requires Dropwizard metrics setup)
.. metrics-ls: show all available metrics
.. metrics-info: show particular metrics
. Various commands
.. echo
.. sleep
.. help
.. exit
.. logout
. Job control
.. fg
.. bg
.. jobs

NOTE: this command list should evolve in next releases of Vert.x Shell

== Extending Vert.x Shell

Vert.x Shell can be extended with custom commands in any of the languages supporting code generation.

A command is created by the `link:../../jsdoc/command_builder-CommandBuilder.html#command[CommandBuilder.command]` method: the command process handler is called
by the shell when the command is executed, this handler can be set with the `link:../../jsdoc/command_builder-CommandBuilder.html#processHandler[processHandler]`
method:

[source,js]
----
var CommandBuilder = require("vertx-shell-js/command_builder");
var CommandRegistry = require("vertx-shell-js/command_registry");

var builder = CommandBuilder.command("my-command");
builder.processHandler(function (process) {

  // Write a message to the console
  process.write("Hello World");

  // End the process
  process.end();
});

// Register the command
var registry = CommandRegistry.get(vertx);
registry.registerCommand(builder.build());

----

After a command is created, it needs to be registed to a `link:../../jsdoc/command_registry-CommandRegistry.html[CommandRegistry]`. The
command registry holds all the commands for a Vert.x instance.

A command is registered until it is unregistered with the `link:../../jsdoc/command_registration-CommandRegistration.html#unregister[unregister]`
method or the `link:../../jsdoc/command_registry-CommandRegistry.html#unregisterCommand[unregisterCommand]`. When a command is
registered from a Verticle, this command is unregistered when this verticle is undeployed.

NOTE: Command callbacks are invoked in the `io.vertx.core.Context` when the command is registered in the
registry. Keep this in mind if you maintain state in a command.

The `link:../../jsdoc/command_process-CommandProcess.html[CommandProcess]` object can be used for interacting with the shell.

=== Command arguments

The `link:../../jsdoc/command_process-CommandProcess.html#args[args]` returns the command arguments:

[source,js]
----
command.processHandler(function (process) {

  Array.prototype.forEach.call(process.args(), function(arg) {
    // Print each argument on the console
    process.write("Argument " + arg);
  });

  process.end();
});

----

Besides it is also possible to create commands using `link:../../jsdoc/cli-CLI.html[Vert.x CLI]`: it makes easier to
write command line argument parsing:

- _option_ and _argument_ parsing
- argument _validation_
- generation of the command _usage_

[source,js]
----
var CLI = require("vertx-js/cli");
var CommandBuilder = require("vertx-shell-js/command_builder");
var cli = CLI.create("my-command").addArgument({
  "argName" : "my-arg"
}).addOption({
  "shortName" : "m",
  "longName" : "my-option"
});
var command = CommandBuilder.command(cli);
command.processHandler(function (process) {

  var commandLine = process.commandLine();

  var argValue = commandLine.getArgumentValue(0);
  var optValue = commandLine.getOptionValue("my-option");
  process.write("The argument is " + argValue + " and the option is " + optValue);

  process.end();
});

----

When an option named _help_ is added to the CLI object, the shell will take care of generating the command usage
when the option is activated:

[source,js]
----
var CLI = require("vertx-js/cli");
var CommandBuilder = require("vertx-shell-js/command_builder");
var cli = CLI.create("my-command").addArgument({
  "argName" : "my-arg"
}).addOption({
  "argName" : "help",
  "shortName" : "h",
  "longName" : "help"
});
var command = CommandBuilder.command(cli);
command.processHandler(function (process) {
  // ...
});

----

When the command executes the `link:../../jsdoc/command_process-CommandProcess.html[process]` is provided for interacting
with the shell. A `link:../../jsdoc/command_process-CommandProcess.html[CommandProcess]` extends `link:../../jsdoc/tty-Tty.html[Tty]`
which is used for interacting with the terminal.

=== Terminal usage

==== terminal I/O

The `link:../../jsdoc/tty-Tty.html#setStdin[setStdin]` handler is used to be notified when the terminal
receives data, e.g the user uses his keyboard:

[source,js]
----
tty.setStdin(function (data) {
  console.log("Received " + data);
});

----

A command can use the `link:../../jsdoc/tty-Tty.html#stdout[stdout]` to write to the standard output.

[source,js]
----
tty.stdout().write("Hello World");

----

==== Terminal size

The current terminal size can be obtained using `link:../../jsdoc/tty-Tty.html#width[width]` and
`link:../../jsdoc/tty-Tty.html#height[height]`.

[source,js]
----
tty.stdout().write("Current terminal size: (" + tty.width() + ", " + tty.height() + ")");

----

==== Resize event

When the size of the terminal changes the `link:../../jsdoc/tty-Tty.html#resizehandler[resizehandler]`
is called, the new terminal size can be obtained with `link:../../jsdoc/tty-Tty.html#width[width]` and
`link:../../jsdoc/tty-Tty.html#height[height]`.

[source,js]
----
tty.resizehandler(function (v) {
  console.log("terminal resized : " + tty.width() + " " + tty.height());
});

----

==== Terminal type

The terminal type is useful for sending escape codes to the remote terminal: `link:../../jsdoc/tty-Tty.html#type[type]`
returns the current terminal type, it can be null if the terminal has not advertised the value.

[source,js]
----
console.log("terminal type : " + tty.type());

----

=== Shell session

The shell is a connected service that naturally maintains a session with the client, this session can be
used in commands to scope data. A command can get the session with `link:../../jsdoc/command_process-CommandProcess.html#session[session]`:

[source,js]
----
command.processHandler(function (process) {

  var session = process.session();

  if (session.get("my_key") === null) {
    session.put("my key", "my value");
  }

  process.end();
});

----

=== Process termination

Calling `link:../../jsdoc/command_process-CommandProcess.html#end[end]` ends the current process. It can be called directly
in the invocation of the command handler or any time later:

[source,js]
----
command.processHandler(function (process) {
  var vertx = process.vertx();

  // Set a timer
  vertx.setTimer(1000, function (id) {

    // End the command when the timer is fired
    process.end();
  });
});

----

=== Process events

A command can subscribe to a few process events.

==== Interrupt event

The `link:../../jsdoc/command_process-CommandProcess.html#interruptHandler[interruptHandler]` is called when the process
is interrupted, this event is fired when the user press _Ctrl+C_ during the execution of a command. This handler can
be used for interrupting commands _blocking_ the CLI and gracefully ending the command process:

[source,js]
----
command.processHandler(function (process) {
  var vertx = process.vertx();

  // Every second print a message on the console
  var periodicId = vertx.setPeriodic(1000, function (id) {
    process.write("tick\n");
  });

  // When user press Ctrl+C: cancel the timer and end the process
  process.interruptHandler(function (v) {
    vertx.cancelTimer(periodicId);
    process.end();
  });
});

----

When no interrupt handler is registered, pressing _Ctrl+C_ will have no effect on the current process and the event
will be delayed and will likely be handled by the shell, like printing a new line on the console.

==== Suspend/resume events

The `link:../../jsdoc/command_process-CommandProcess.html#suspendHandler[suspendHandler]` is called when the process
is running and the user press _Ctrl+Z_, the command is _suspended_:

- the command can receive the suspend event when it has registered an handler for this event
- the command will not receive anymore data from the standard input
- the shell prompt the user for input
- the command can receive interrupts event or end events

The `link:../../jsdoc/command_process-CommandProcess.html#resumeHandler[resumeHandler]` is called when the process
is resumed, usually when the user types _fg_:

- the command can receive the resume event when it has registered an handler for this event
- the command will receive again data from the standard input when it has registered an stdin handler

[source,js]
----
command.processHandler(function (process) {

  // Command is suspended
  process.suspendHandler(function (v) {
    console.log("Suspended");
  });

  // Command is resumed
  process.resumeHandler(function (v) {
    console.log("Resumed");
  });
});

----

==== End events

The `link:../../jsdoc/command_process-CommandProcess.html#endHandler[endHandler]` (io.vertx.core.Handler)} is
called when the process is running or suspended and the command terminates, for instance the shell session is closed,
the command is _terminated_.

[source,js]
----
command.processHandler(function (process) {

  // Command terminates
  process.endHandler(function (v) {
    console.log("Terminated");
  });
});

----

The end handler is called even when the command invokes `link:../../jsdoc/command_process-CommandProcess.html#end[end]`.

This handler is useful for cleaning up resources upon command termination, for instance closing a client or a timer.

=== Command completion

A command can provide a completion handler when it wants to provide contextual command line interface completion.

Like the process handler, the `link:../../jsdoc/command_builder-CommandBuilder.html#completionHandler[completion
handler]` is non blocking because the implementation may use Vert.x services, e.g the file system.

The `link:../../jsdoc/completion-Completion.html#lineTokens[lineTokens]` returns a list of `link:../../jsdoc/cli_token-CliToken.html[tokens]`
from the beginning of the line to the cursor position. The list can be empty if the cursor when the cursor is at the
beginning of the line.

The `link:../../jsdoc/completion-Completion.html#rawLine[rawLine]` returns the current completed from the beginning
of the line to the cursor position, in raw format, i.e without any char escape performed.

Completion ends with a call to `link:../../jsdoc/completion-Completion.html#complete[complete]`.

== Shell server

The Shell service is a convenient facade for starting a preconfigured shell either programmatically or as a Vert.x service.
When more flexibility is needed, a `link:../../jsdoc/shell_server-ShellServer.html[ShellServer]` can be used instead of the service.

For instance the shell http term can be configured to use an existing router instead of starting its own http server.

Using a shell server requires explicit configuration but provides full flexiblity, a shell server is setup in a few
steps:

[source,js]
----
var ShellServer = require("vertx-shell-js/shell_server");
var Router = require("vertx-web-js/router");
var TermServer = require("vertx-shell-js/term_server");
var Command = require("vertx-shell-js/command");

var server = ShellServer.create(vertx);

var shellRouter = Router.router(vertx);
router.mountSubRouter("/shell", shellRouter);
var httpTermServer = TermServer.createHttpTermServer(vertx, router);

var sshTermServer = TermServer.createSSHTermServer(vertx);

server.registerTermServer(httpTermServer);
server.registerTermServer(sshTermServer);

server.commandRegistry().registerCommands(Command.baseCommands());

server.listen();

----
<1> create a the shell server
<2> create an HTTP term server mounted on an existing router
<3> create an SSH term server
<4> register term servers
<5> register all base commands
<6> finally start the shell server

Besides, the shell server can also be used for creating in process shell session: it provides a programmatic interactive shell.

In process shell session can be created with `link:../../jsdoc/shell_server-ShellServer.html#createShell[createShell]`:

[source,js]
----

// Create a shell ession
var shell = shellServer.createShell();


----

The main use case is running or testing a command:

[source,js]
----
var Pty = require("vertx-shell-js/pty");

// Create a shell
var shell = shellServer.createShell();

// Create a job fo the command
var job = shell.createJob("my-command 1234");

// Create a pseudo terminal
var pty = Pty.create();
pty.setStdout(function (data) {
  console.log("Command wrote " + data);
});

// Run the command
job.setTty(pty.slave());
job.terminateHandler(function (status) {
  console.log("Command terminated with status " + status);
});

----

The `link:../../jsdoc/pty-Pty.html[Pty]` pseudo terminal is the main interface for interacting with the command
when it's running:

- uses standard input/output for writing or reading strings
- resize the terminal

The `link:../../jsdoc/shell-Shell.html#close[close]` closes the shell, it will terminate all jobs in the current shell
session.

== Terminal servers

Vert.x Shell also provides bare terminal servers for those who need to write pure terminal applications.

A `link:../../jsdoc/term-Term.html[Term]` handler must be set on a term server before starting it. This handler will
handle each term when the user connects.

An `link:../../vertx-auth-common/dataobjects.html#AuthOptions[AuthOptions]` can be set on `link:../dataobjects.html#SSHTermOptions[SSHTermOptions]` and `link:../dataobjects.html#HttpTermOptions[HttpTermOptions]`.
Alternatively, an `link:../../jsdoc/auth_provider-AuthProvider.html[AuthProvider]` can be `link:../../jsdoc/term_server-TermServer.html#authProvider[set]`
directly on the term server before starting it.

=== SSH term

The terminal server `link:../../jsdoc/term-Term.html[Term]` handler accepts incoming terminal connections.
When a remote terminal connects, the `link:../../jsdoc/term-Term.html[Term]` can be used to interact with connected
terminal.

[source,js]
----
var TermServer = require("vertx-shell-js/term_server");
var server = TermServer.createSSHTermServer(vertx, {
  "port" : 5000,
  "host" : "localhost"
});
server.termHandler(function (term) {
  term.setStdin(function (line) {
    term.stdout().write(line);
  });
});
server.listen();

----

The `link:../../jsdoc/term-Term.html[Term]` is also a `link:../../jsdoc/tty-Tty.html[Tty]`, this section explains
how to use the tty.

=== Telnet term

[source,js]
----
var TermServer = require("vertx-shell-js/term_server");
var server = TermServer.createTelnetTermServer(vertx, {
  "port" : 5000,
  "host" : "localhost"
});
server.termHandler(function (term) {
  term.setStdin(function (line) {
    term.stdout().write(line);
  });
});
server.listen();

----

=== HTTP term

The `link:../../jsdoc/term_server-TermServer.html#createHttpTermServer[TermServer.createHttpTermServer]` method creates an HTTP term server, built
on top of Vert.x Web using the SockJS protocol.

[source,js]
----
var TermServer = require("vertx-shell-js/term_server");
var server = TermServer.createHttpTermServer(vertx, {
  "port" : 5000,
  "host" : "localhost"
});
server.termHandler(function (term) {
  term.setStdin(function (line) {
    term.stdout().write(line);
  });
});
server.listen();

----

An HTTP term can start its own HTTP server, or it can reuse an existing Vert.x Web `link:../../jsdoc/router-Router.html[Router]`.

The shell can be found at `/shell.html`.

[source,js]
----
var TermServer = require("vertx-shell-js/term_server");
var server = TermServer.createHttpTermServer(vertx, router, {
  "port" : 5000,
  "host" : "localhost"
});
server.termHandler(function (term) {
  term.setStdin(function (line) {
    term.stdout().write(line);
  });
});
server.listen();

----

The later option is convenient when the HTTP shell is integrated in an existing HTTP server.

The HTTP term server by default is configured for serving:

- the `shell.html` page
- the `https://github.com/chjj/term.js/[term.js]` client library
- the `vertxshell.js` client library

The `vertxshell.js` integrates `term.js` is the client side part of the HTTP term.

It integrates `term.js` with SockJS and needs the URL of the HTTP term server endpoint:

[source,javascript]
----
window.addEventListener('load', function () {
  var url = 'http://localhost/shell';
  new VertxTerm(url, {
    cols: 80,
    rows: 24
   });
 });
----

Straight websockets can also be used, if so, the remote term URL should be suffixed with `/websocket`:

[source,javascript]
----
window.addEventListener('load', function () {
  var url = 'ws://localhost/shell/websocket';
  new VertxTerm(url, {
    cols: 80,
    rows: 24
   });
 });
----

For customization purpose these resources can be copied and customized, they are available in the Vert.x Shell
jar under the `io.vertx.ext.shell` packages.